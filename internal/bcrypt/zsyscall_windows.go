// Code generated by 'go generate'; DO NOT EDIT.

package bcrypt

import (
	"github.com/microsoft/go-crypto-winnative/internal/sysdll"
	"syscall"
	"unsafe"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modbcrypt = syscall.NewLazyDLL(sysdll.Add("bcrypt.dll"))

	procBCryptCloseAlgorithmProvider = modbcrypt.NewProc("BCryptCloseAlgorithmProvider")
	procBCryptCreateHash             = modbcrypt.NewProc("BCryptCreateHash")
	procBCryptDecrypt                = modbcrypt.NewProc("BCryptDecrypt")
	procBCryptDeriveKey              = modbcrypt.NewProc("BCryptDeriveKey")
	procBCryptDestroyHash            = modbcrypt.NewProc("BCryptDestroyHash")
	procBCryptDestroyKey             = modbcrypt.NewProc("BCryptDestroyKey")
	procBCryptDestroySecret          = modbcrypt.NewProc("BCryptDestroySecret")
	procBCryptDuplicateHash          = modbcrypt.NewProc("BCryptDuplicateHash")
	procBCryptEncrypt                = modbcrypt.NewProc("BCryptEncrypt")
	procBCryptExportKey              = modbcrypt.NewProc("BCryptExportKey")
	procBCryptFinalizeKeyPair        = modbcrypt.NewProc("BCryptFinalizeKeyPair")
	procBCryptFinishHash             = modbcrypt.NewProc("BCryptFinishHash")
	procBCryptGenRandom              = modbcrypt.NewProc("BCryptGenRandom")
	procBCryptGenerateKeyPair        = modbcrypt.NewProc("BCryptGenerateKeyPair")
	procBCryptGenerateSymmetricKey   = modbcrypt.NewProc("BCryptGenerateSymmetricKey")
	procBCryptGetFipsAlgorithmMode   = modbcrypt.NewProc("BCryptGetFipsAlgorithmMode")
	procBCryptGetProperty            = modbcrypt.NewProc("BCryptGetProperty")
	procBCryptHash                   = modbcrypt.NewProc("BCryptHash")
	procBCryptHashData               = modbcrypt.NewProc("BCryptHashData")
	procBCryptImportKeyPair          = modbcrypt.NewProc("BCryptImportKeyPair")
	procBCryptKeyDerivation          = modbcrypt.NewProc("BCryptKeyDerivation")
	procBCryptOpenAlgorithmProvider  = modbcrypt.NewProc("BCryptOpenAlgorithmProvider")
	procBCryptSecretAgreement        = modbcrypt.NewProc("BCryptSecretAgreement")
	procBCryptSetProperty            = modbcrypt.NewProc("BCryptSetProperty")
	procBCryptSignHash               = modbcrypt.NewProc("BCryptSignHash")
	procBCryptVerifySignature        = modbcrypt.NewProc("BCryptVerifySignature")
)

func CloseAlgorithmProvider(hAlgorithm ALG_HANDLE, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptCloseAlgorithmProvider.Addr(), 2, uintptr(hAlgorithm), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func CreateHash(hAlgorithm ALG_HANDLE, phHash *HASH_HANDLE, pbHashObject []byte, pbSecret []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbHashObject) > 0 {
		_p0 = &pbHashObject[0]
	}
	var _p1 *byte
	if len(pbSecret) > 0 {
		_p1 = &pbSecret[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptCreateHash.Addr(), 7, uintptr(hAlgorithm), uintptr(unsafe.Pointer(phHash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHashObject)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSecret)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func Decrypt(hKey KEY_HANDLE, pbInput []byte, pPaddingInfo unsafe.Pointer, pbIV []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (s error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	var _p1 *byte
	if len(pbIV) > 0 {
		_p1 = &pbIV[0]
	}
	var _p2 *byte
	if len(pbOutput) > 0 {
		_p2 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall12(procBCryptDecrypt.Addr(), 10, uintptr(hKey), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbIV)), uintptr(unsafe.Pointer(_p2)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DeriveKey(hSharedSecret SECRET_HANDLE, pwszKDF *uint16, pParameterList *BufferDesc, pbDerivedKey []byte, pcbResult *uint32, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbDerivedKey) > 0 {
		_p0 = &pbDerivedKey[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptDeriveKey.Addr(), 7, uintptr(hSharedSecret), uintptr(unsafe.Pointer(pwszKDF)), uintptr(unsafe.Pointer(pParameterList)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbDerivedKey)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DestroyHash(hHash HASH_HANDLE) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptDestroyHash.Addr(), 1, uintptr(hHash), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DestroyKey(hKey KEY_HANDLE) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptDestroyKey.Addr(), 1, uintptr(hKey), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DestroySecret(hSecret SECRET_HANDLE) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptDestroySecret.Addr(), 1, uintptr(hSecret), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DuplicateHash(hHash HASH_HANDLE, phNewHash *HASH_HANDLE, pbHashObject []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbHashObject) > 0 {
		_p0 = &pbHashObject[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptDuplicateHash.Addr(), 5, uintptr(hHash), uintptr(unsafe.Pointer(phNewHash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHashObject)), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func _Encrypt(hKey KEY_HANDLE, pbInput *byte, cbInput uint32, pPaddingInfo unsafe.Pointer, pbIV []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (s error) {
	var _p0 *byte
	if len(pbIV) > 0 {
		_p0 = &pbIV[0]
	}
	var _p1 *byte
	if len(pbOutput) > 0 {
		_p1 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall12(procBCryptEncrypt.Addr(), 10, uintptr(hKey), uintptr(unsafe.Pointer(pbInput)), uintptr(cbInput), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbIV)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func ExportKey(hKey KEY_HANDLE, hExportKey KEY_HANDLE, pszBlobType *uint16, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbOutput) > 0 {
		_p0 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptExportKey.Addr(), 7, uintptr(hKey), uintptr(hExportKey), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func FinalizeKeyPair(hKey KEY_HANDLE, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptFinalizeKeyPair.Addr(), 2, uintptr(hKey), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func FinishHash(hHash HASH_HANDLE, pbOutput []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbOutput) > 0 {
		_p0 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptFinishHash.Addr(), 4, uintptr(hHash), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func GenRandom(hAlgorithm ALG_HANDLE, pbBuffer []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbBuffer) > 0 {
		_p0 = &pbBuffer[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptGenRandom.Addr(), 4, uintptr(hAlgorithm), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbBuffer)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func GenerateKeyPair(hAlgorithm ALG_HANDLE, phKey *KEY_HANDLE, dwLength uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptGenerateKeyPair.Addr(), 4, uintptr(hAlgorithm), uintptr(unsafe.Pointer(phKey)), uintptr(dwLength), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func generateSymmetricKey(hAlgorithm ALG_HANDLE, phKey *KEY_HANDLE, pbKeyObject []byte, pbSecret *byte, cbSecret uint32, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbKeyObject) > 0 {
		_p0 = &pbKeyObject[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptGenerateSymmetricKey.Addr(), 7, uintptr(hAlgorithm), uintptr(unsafe.Pointer(phKey)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbKeyObject)), uintptr(unsafe.Pointer(pbSecret)), uintptr(cbSecret), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func GetFipsAlgorithmMode(enabled *bool) (s error) {
	var _p0 uint32
	if *enabled {
		_p0 = 1
	}
	r0, _, _ := syscall.Syscall(procBCryptGetFipsAlgorithmMode.Addr(), 1, uintptr(unsafe.Pointer(&_p0)), 0, 0)
	*enabled = _p0 != 0
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func GetProperty(hObject HANDLE, pszProperty *uint16, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbOutput) > 0 {
		_p0 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptGetProperty.Addr(), 6, uintptr(hObject), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func Hash(hAlgorithm ALG_HANDLE, pbSecret []byte, pbInput []byte, pbOutput []byte) (s error) {
	var _p0 *byte
	if len(pbSecret) > 0 {
		_p0 = &pbSecret[0]
	}
	var _p1 *byte
	if len(pbInput) > 0 {
		_p1 = &pbInput[0]
	}
	var _p2 *byte
	if len(pbOutput) > 0 {
		_p2 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptHash.Addr(), 7, uintptr(hAlgorithm), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbSecret)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbInput)), uintptr(unsafe.Pointer(_p2)), uintptr(len(pbOutput)), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func HashDataRaw(hHash HASH_HANDLE, pbInput *byte, cbInput uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptHashData.Addr(), 4, uintptr(hHash), uintptr(unsafe.Pointer(pbInput)), uintptr(cbInput), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func HashData(hHash HASH_HANDLE, pbInput []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptHashData.Addr(), 4, uintptr(hHash), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func ImportKeyPair(hAlgorithm ALG_HANDLE, hImportKey KEY_HANDLE, pszBlobType *uint16, phKey *KEY_HANDLE, pbInput []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptImportKeyPair.Addr(), 7, uintptr(hAlgorithm), uintptr(hImportKey), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(phKey)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func KeyDerivation(hKey KEY_HANDLE, pParameterList *BufferDesc, pbDerivedKey []byte, pcbResult *uint32, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbDerivedKey) > 0 {
		_p0 = &pbDerivedKey[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptKeyDerivation.Addr(), 6, uintptr(hKey), uintptr(unsafe.Pointer(pParameterList)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbDerivedKey)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func OpenAlgorithmProvider(phAlgorithm *ALG_HANDLE, pszAlgId *uint16, pszImplementation *uint16, dwFlags AlgorithmProviderFlags) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptOpenAlgorithmProvider.Addr(), 4, uintptr(unsafe.Pointer(phAlgorithm)), uintptr(unsafe.Pointer(pszAlgId)), uintptr(unsafe.Pointer(pszImplementation)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func SecretAgreement(hPrivKey KEY_HANDLE, hPubKey KEY_HANDLE, phAgreedSecret *SECRET_HANDLE, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptSecretAgreement.Addr(), 4, uintptr(hPrivKey), uintptr(hPubKey), uintptr(unsafe.Pointer(phAgreedSecret)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func SetProperty(hObject HANDLE, pszProperty *uint16, pbInput []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptSetProperty.Addr(), 5, uintptr(hObject), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func SignHash(hKey KEY_HANDLE, pPaddingInfo unsafe.Pointer, pbInput []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (s error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	var _p1 *byte
	if len(pbOutput) > 0 {
		_p1 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptSignHash.Addr(), 8, uintptr(hKey), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func VerifySignature(hKey KEY_HANDLE, pPaddingInfo unsafe.Pointer, pbHash []byte, pbSignature []byte, dwFlags PadMode) (s error) {
	var _p0 *byte
	if len(pbHash) > 0 {
		_p0 = &pbHash[0]
	}
	var _p1 *byte
	if len(pbSignature) > 0 {
		_p1 = &pbSignature[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptVerifySignature.Addr(), 7, uintptr(hKey), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHash)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSignature)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}
