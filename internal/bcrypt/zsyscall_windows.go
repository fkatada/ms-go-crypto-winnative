// Code generated by 'go generate'; DO NOT EDIT.

package bcrypt

import (
	"github.com/microsoft/go-crypto-winnative/internal/sysdll"
	"syscall"
	"unsafe"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modbcrypt = syscall.NewLazyDLL(sysdll.Add("bcrypt.dll"))

	procBCryptCloseAlgorithmProvider = modbcrypt.NewProc("BCryptCloseAlgorithmProvider")
	procBCryptCreateHash             = modbcrypt.NewProc("BCryptCreateHash")
	procBCryptDecrypt                = modbcrypt.NewProc("BCryptDecrypt")
	procBCryptDestroyHash            = modbcrypt.NewProc("BCryptDestroyHash")
	procBCryptDestroyKey             = modbcrypt.NewProc("BCryptDestroyKey")
	procBCryptDuplicateHash          = modbcrypt.NewProc("BCryptDuplicateHash")
	procBCryptEncrypt                = modbcrypt.NewProc("BCryptEncrypt")
	procBCryptExportKey              = modbcrypt.NewProc("BCryptExportKey")
	procBCryptFinalizeKeyPair        = modbcrypt.NewProc("BCryptFinalizeKeyPair")
	procBCryptFinishHash             = modbcrypt.NewProc("BCryptFinishHash")
	procBCryptGenRandom              = modbcrypt.NewProc("BCryptGenRandom")
	procBCryptGenerateKeyPair        = modbcrypt.NewProc("BCryptGenerateKeyPair")
	procBCryptGenerateSymmetricKey   = modbcrypt.NewProc("BCryptGenerateSymmetricKey")
	procBCryptGetProperty            = modbcrypt.NewProc("BCryptGetProperty")
	procBCryptHashData               = modbcrypt.NewProc("BCryptHashData")
	procBCryptImportKeyPair          = modbcrypt.NewProc("BCryptImportKeyPair")
	procBCryptOpenAlgorithmProvider  = modbcrypt.NewProc("BCryptOpenAlgorithmProvider")
	procBCryptSetProperty            = modbcrypt.NewProc("BCryptSetProperty")
)

func CloseAlgorithmProvider(hAlgorithm ALG_HANDLE, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptCloseAlgorithmProvider.Addr(), 2, uintptr(hAlgorithm), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func CreateHash(hAlgorithm ALG_HANDLE, phHash *HASH_HANDLE, pbHashObject []byte, pbSecret []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbHashObject) > 0 {
		_p0 = &pbHashObject[0]
	}
	var _p1 *byte
	if len(pbSecret) > 0 {
		_p1 = &pbSecret[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptCreateHash.Addr(), 7, uintptr(hAlgorithm), uintptr(unsafe.Pointer(phHash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHashObject)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSecret)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func Decrypt(hKey KEY_HANDLE, pbInput []byte, pPaddingInfo *AUTHENTICATED_CIPHER_MODE_INFO, pbIV []byte, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	var _p1 *byte
	if len(pbIV) > 0 {
		_p1 = &pbIV[0]
	}
	var _p2 *byte
	if len(pbOutput) > 0 {
		_p2 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall12(procBCryptDecrypt.Addr(), 10, uintptr(hKey), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(unsafe.Pointer(pPaddingInfo)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbIV)), uintptr(unsafe.Pointer(_p2)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DestroyHash(hHash HASH_HANDLE) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptDestroyHash.Addr(), 1, uintptr(hHash), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DestroyKey(hKey KEY_HANDLE) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptDestroyKey.Addr(), 1, uintptr(hKey), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DuplicateHash(hHash HASH_HANDLE, phNewHash *HASH_HANDLE, pbHashObject []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbHashObject) > 0 {
		_p0 = &pbHashObject[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptDuplicateHash.Addr(), 5, uintptr(hHash), uintptr(unsafe.Pointer(phNewHash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHashObject)), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func Encrypt(hKey KEY_HANDLE, pbInput []byte, pPaddingInfo *AUTHENTICATED_CIPHER_MODE_INFO, pbIV []byte, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	var _p1 *byte
	if len(pbIV) > 0 {
		_p1 = &pbIV[0]
	}
	var _p2 *byte
	if len(pbOutput) > 0 {
		_p2 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall12(procBCryptEncrypt.Addr(), 10, uintptr(hKey), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(unsafe.Pointer(pPaddingInfo)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbIV)), uintptr(unsafe.Pointer(_p2)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func ExportKey(hKey KEY_HANDLE, hExportKey KEY_HANDLE, pszBlobType *uint16, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbOutput) > 0 {
		_p0 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptExportKey.Addr(), 7, uintptr(hKey), uintptr(hExportKey), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func FinalizeKeyPair(hKey KEY_HANDLE, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptFinalizeKeyPair.Addr(), 2, uintptr(hKey), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func FinishHash(hHash HASH_HANDLE, pbOutput []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbOutput) > 0 {
		_p0 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptFinishHash.Addr(), 4, uintptr(hHash), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func GenRandom(hAlgorithm ALG_HANDLE, pbBuffer []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbBuffer) > 0 {
		_p0 = &pbBuffer[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptGenRandom.Addr(), 4, uintptr(hAlgorithm), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbBuffer)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func GenerateKeyPair(hAlgorithm ALG_HANDLE, phKey *KEY_HANDLE, dwLength uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptGenerateKeyPair.Addr(), 4, uintptr(hAlgorithm), uintptr(unsafe.Pointer(phKey)), uintptr(dwLength), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func GenerateSymmetricKey(hAlgorithm ALG_HANDLE, phKey *KEY_HANDLE, pbKeyObject []byte, pbSecret []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbKeyObject) > 0 {
		_p0 = &pbKeyObject[0]
	}
	var _p1 *byte
	if len(pbSecret) > 0 {
		_p1 = &pbSecret[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptGenerateSymmetricKey.Addr(), 7, uintptr(hAlgorithm), uintptr(unsafe.Pointer(phKey)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbKeyObject)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSecret)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func GetProperty(hObject HANDLE, pszProperty *uint16, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbOutput) > 0 {
		_p0 = &pbOutput[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptGetProperty.Addr(), 6, uintptr(hObject), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func HashData(hHash HASH_HANDLE, pbInput []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptHashData.Addr(), 4, uintptr(hHash), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func ImportKeyPair(hAlgorithm ALG_HANDLE, hImportKey KEY_HANDLE, pszBlobType *uint16, phKey *KEY_HANDLE, pbInput []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptImportKeyPair.Addr(), 7, uintptr(hAlgorithm), uintptr(hImportKey), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(phKey)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func OpenAlgorithmProvider(phAlgorithm *ALG_HANDLE, pszAlgId *uint16, pszImplementation *uint16, dwFlags AlgorithmProviderFlags) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptOpenAlgorithmProvider.Addr(), 4, uintptr(unsafe.Pointer(phAlgorithm)), uintptr(unsafe.Pointer(pszAlgId)), uintptr(unsafe.Pointer(pszImplementation)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func SetProperty(hObject HANDLE, pszProperty *uint16, pbInput []byte, dwFlags uint32) (s error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptSetProperty.Addr(), 5, uintptr(hObject), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}
