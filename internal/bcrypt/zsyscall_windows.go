// Code generated by 'go generate'; DO NOT EDIT.

package bcrypt

import (
	"github.com/microsoft/go-crypto-winnative/internal/sysdll"
	"syscall"
	"unsafe"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modbcrypt = syscall.NewLazyDLL(sysdll.Add("bcrypt.dll"))

	procBCryptCloseAlgorithmProvider = modbcrypt.NewProc("BCryptCloseAlgorithmProvider")
	procBCryptCreateHash             = modbcrypt.NewProc("BCryptCreateHash")
	procBCryptDestroyHash            = modbcrypt.NewProc("BCryptDestroyHash")
	procBCryptDuplicateHash          = modbcrypt.NewProc("BCryptDuplicateHash")
	procBCryptFinishHash             = modbcrypt.NewProc("BCryptFinishHash")
	procBCryptGetProperty            = modbcrypt.NewProc("BCryptGetProperty")
	procBCryptHashData               = modbcrypt.NewProc("BCryptHashData")
	procBCryptOpenAlgorithmProvider  = modbcrypt.NewProc("BCryptOpenAlgorithmProvider")
)

func CloseAlgorithmProvider(phAlgorithm ALG_HANDLE, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptCloseAlgorithmProvider.Addr(), 2, uintptr(phAlgorithm), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func CreateHash(hAlgorithm ALG_HANDLE, phHash *HASH_HANDLE, pbHashObject *byte, cbHashObject uint32, pbSecret *byte, cbSecret uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall9(procBCryptCreateHash.Addr(), 7, uintptr(hAlgorithm), uintptr(unsafe.Pointer(phHash)), uintptr(unsafe.Pointer(pbHashObject)), uintptr(cbHashObject), uintptr(unsafe.Pointer(pbSecret)), uintptr(cbSecret), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DestroyHash(hHash HASH_HANDLE) (s error) {
	r0, _, _ := syscall.Syscall(procBCryptDestroyHash.Addr(), 1, uintptr(hHash), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func DuplicateHash(hHash HASH_HANDLE, phNewHash *HASH_HANDLE, pbHashObject *byte, cbHashObject uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptDuplicateHash.Addr(), 5, uintptr(hHash), uintptr(unsafe.Pointer(phNewHash)), uintptr(unsafe.Pointer(pbHashObject)), uintptr(cbHashObject), uintptr(dwFlags), 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func FinishHash(hHash HASH_HANDLE, pbOutput *byte, cbOutput uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptFinishHash.Addr(), 4, uintptr(hHash), uintptr(unsafe.Pointer(pbOutput)), uintptr(cbOutput), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func GetProperty(hObject HANDLE, pszProperty *uint16, pbOutput *byte, cbOutput uint32, pcbResult *uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptGetProperty.Addr(), 6, uintptr(hObject), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(pbOutput)), uintptr(cbOutput), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func HashData(hHash HASH_HANDLE, pbInput *byte, cbInput uint32, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptHashData.Addr(), 4, uintptr(hHash), uintptr(unsafe.Pointer(pbInput)), uintptr(cbInput), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}

func OpenAlgorithmProvider(phAlgorithm *ALG_HANDLE, pszAlgId *uint16, pszImplementation *uint16, dwFlags uint32) (s error) {
	r0, _, _ := syscall.Syscall6(procBCryptOpenAlgorithmProvider.Addr(), 4, uintptr(unsafe.Pointer(phAlgorithm)), uintptr(unsafe.Pointer(pszAlgId)), uintptr(unsafe.Pointer(pszImplementation)), uintptr(dwFlags), 0, 0)
	if r0 != 0 {
		s = syscall.Errno(r0)
	}
	return
}
